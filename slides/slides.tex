% vim: ts=2 sw=2 et:
\documentclass[xetex, handout]{beamer}
\usetheme{hsr}

\usepackage[T1]{fontenc}
\usepackage{cmbright}
\usepackage{unicode-math}

\usefonttheme{structurebold}

\usepackage{amsmath}
\usepackage{amssymb}

\usepackage{tikz}

\usetikzlibrary{backgrounds}
\usetikzlibrary{bending}
\usetikzlibrary{calc}
\usetikzlibrary{decorations.pathreplacing}
\usetikzlibrary{fadings}
\usetikzlibrary{matrix}
\usetikzlibrary{positioning}
\usetikzlibrary{trees}

\pgfdeclarelayer{bg}
\pgfsetlayers{bg,main}

\tikzset{
  db/.pic={
    \draw[white, fill=white] (-.6,0) rectangle (.6,1.4);
    \draw[white, fill=white] (0,1.4) ellipse [x radius=.6,y radius=.15];
    \foreach \y in {0,.5,1}
    {
      \draw[thick, fill=white]
        (-0.6,\y) to [looseness=0.5,bend right=90] ++(1.2,0)
              to ++(0,0.4)
              to [looseness=0.5,bend left=90] ++(-1.2,0)
              to ++(0,-0.4);
      \draw[thick] (-0.6,\y+0.4) edge[looseness=0.5,bend left=90] ++(1.2,0);
    }
  },
  pics/file/.style args = {#1 #2 #3}{
    code = {
      % Rectangle
      \node[
        outer sep = 0, inner sep = 0,
        minimum width = 1cm, minimum height = 1.2cm,
        #3
      ] (#1) {#2};
      % Paper outline
      \draw[thick, fill = white]
        ({#1}.north west) -- ($({#1}.north east) - (.3,0)$)
          -- ++(0,-.3) -- ++(.3,0) -- ({#1}.south east)
          -- ({#1}.south west) -- ({#1}.north west) -- cycle;
      % Fill inside paper
      \draw[fill = white] 
        ($({#1}.north east) - (.3,0)$) to ++(0,-.3) 
        to ++(.3,0) to ++(-.3,.3) to cycle;
      % Paper angle
      \draw[black, thick] ($({#1}.north east) - (.3,0)$) to ++(.3,-.3);
      % Text inside paper
      \node[
        outer sep = 1mm,
        inner sep = 0,
        minimum width = 1cm,
        minimum height = 1.2cm,
      ] (#1) at (#1) {#2};
    },
  },
}


\title{Introduction to Git}
\subtitle{``The stupid content tracker''}
\author{
  Naoki Pross --- \texttt{np@0hm.ch}
}
\institute{}

\date{XX. March 2025}

\AtBeginSection[]
{
  \begin{frame}[shrink]{Table of Contents}
    \tableofcontents[
      currentsection,
      hideothersubsections,
      sectionstyle=show/shaded,
    ]
  \end{frame}
}

\begin{document}

\frame{\titlepage}

\begin{frame}{Obligatory XKCD}
  \begin{columns}
    \begin{column}{.5\linewidth}
      \includegraphics[width=\linewidth]{pic/xkcd1597}
    \end{column}
    \begin{column}{.5\linewidth}
      \begin{alertblock}{Plan for Today}
        \begin{enumerate}
          \item A tiny bit of graph theory and even less cryptography
          \item Understand (instead of memorizing) Git
          \item Flex on your n00b friends by finding what caused a bug using a
            logarithmic search over the directed acyclic graph that represents
            the change history
          \item Put it on your CV and profit
        \end{enumerate}
      \end{alertblock}
    \end{column}
  \end{columns}
\end{frame}

% \begin{frame}{About You and Me}
% \end{frame}

\section{The Problem}

\begin{frame}{What do we want?}
  \begin{alertblock}{The Problem}
    Synchronize data across multiple computers, with multiple people working on
    (possibly the same) files.
  \end{alertblock}
  \pause

  \begin{block}{Linus' Wishes (The guy who invented Git)}
    \begin{itemize}
      \item Synchronization \emph{always} works
      \item Teamwork is possible and efficient
      \item Works offline
      \item Fast
    \end{itemize}
    neither \emph{intuitive nor easy to use} were not on his list!
  \end{block}
\end{frame}

\begin{frame}{Other Solutions?}
  \begin{block}{Popular at Linus' Time}
    \begin{description}
      \item[CVS] Slow to synchronize. CVS requires a centralized server which
        can get overloaded, was usually set up by the company IT.
      \item[E-Mail] People sent patch files to each other via email.
    \end{description}
  \end{block}
  \begin{block}{Popular Tools Today}
    \begin{description}
      \item[Cloud Storage] Does not work offline. Their whole business model is
        against you. You have no (real) control over when to sync. Also,
        sharepoint is garbage. No way to compare changes.

      \item[Mercurial (hg)] Learn to walk (Git) before you run.
    \end{description}
  \end{block}
\end{frame}

\section{The Solution}

\begin{frame}{Solving the Problem: Snapshots}
  \begin{center}
    \begin{tikzpicture}
    \node at (-1, 2) [draw, fill=gray!15, thick, font=\ttfamily, left] (P) {Project/};
    \pause
    \draw[black, thick, ->] (P.north east) ++(.2,-.2) arc (-90:180:.5)
        node[pos=.6, above]{Changes};
    \draw[black, thick, ->] (0, 0) -- (7.2, 0) node [below] {Time};
    \foreach \x/\t in {0/16:04:28, 2/16:37:01, 4/17:15:44, 6/18:01:03}
    {
        \pause
        \draw[color=black, fill=magenta, thick] (\x, 0) circle (.12)
            node[below=5pt, anchor=east, rotate=70, font=\ttfamily, align=right] {\tiny 2019-09-18\\\small\t};
        \draw[thick, ->, gray] (-.8, 2) to[bend left, in=120] (\x, .2);
    }
    \end{tikzpicture}
  \end{center}
\end{frame}

\subsection{Commit Graph}

\begin{frame}[fragile]{Solving the Problem: Concurrent Changes I}
  \begin{tikzpicture}[
      commit/.style = {
        draw, fill=orange, circle, thick,
        minimum size = 2.5mm, inner sep = 0, outer sep = 1mm,
      },
    ]
    \matrix (m) [
      column sep = 18mm, row sep = 1cm,
      row 2/.style = {row sep = 5mm},
    ] {
        \pic{file = {fb0 f {}}}; 
      & \pic{file = {fb1 f {}}}; 
      & \pic{file = {fb2 f {}}}; 
      & \pic{file = {fb3 f {}}}; 
      \\
        \node[commit, label={60:A}] (cb0) {};
      & \node[commit, label={60:B}] (cb1) {};
      & \node[commit, label={60:C}] (cb2) {};
      & \node[commit, label={60:M}, fill=magenta] (cb3) {};
        \fill[opacity=.2, magenta] (cb3) circle (5mm);
      \\
      & \node[commit, label={60:B'}] (ca1) {};
      & \node[commit, label={60:C'}] (ca2) {};
      \\
        \pic{file = {fa0 f {}}}; 
      & \pic{file = {fa1 f {}}}; 
      & \pic{file = {fa2 f {}}}; 
      & \pic{file = {fa3 f {}}}; 
      \\
    };

    \node[rotate=90, font={\bfseries}, hsr-blue]  at ($(-.5,0) + (fb0.west)$) {Bob};
    \node[rotate=90, font={\bfseries}, hsr-mauve] at ($(-.5,0) + (fa0.west)$) {Alice};

    \begin{scope}[thick]
      \draw[->] (fb0) -- node[midway, above] {edit} (fb1);
      \draw[<-] (cb0) -- node[midway, above] {from} (cb1);
      \draw[->] (fb1) -- node[midway, above] {edit} (fb2);
      \draw[<-] (cb1) -- node[midway, above] {from} (cb2);

      \draw[->] (fa0) -- node[midway, above] {edit} (fa1);
      \draw[<-] (cb0) to[out=-60, in=180] 
                      node[midway, above, sloped] {from} (ca1);

      \draw[->] (fa1) -- node[midway, above] {edit} (fa2);
      \draw[<-] (ca1) -- node[midway, above] {from} (ca2);

      \draw[->] (fb2) -- node[midway, above] {``sync''} (fb3);
      \draw[<-] (cb2) -- node[midway, above] {from} (cb3);

      \draw[->] (fa2) -- node[midway, above] {``sync''} (fa3);
      \draw[<-] (ca2) to[out=0, in=-120]
                      node[midway, above, sloped] {from} (cb3);

      \begin{scope}[gray]
        \draw[->] (fb0) -- node[midway, left] {save} (cb0);
        \draw[->] (fb1) -- node[midway, left] {save} (cb1);
        \draw[->] (fb2) -- node[midway, left] {save} (cb2);

        \draw[->] (cb0) -- node[midway, left] {copy} (fa0);
        \draw[->] (fa1) -- node[midway, left] {save} (ca1);
        \draw[->] (fa2) -- node[midway, left] {save} (ca2);

        \draw[->] (cb3) -- node[midway, left] {copy} (fb3);
        \draw[->] (cb3) -- node[midway, left] {copy} (fa3);
      \end{scope}
    \end{scope}
  \end{tikzpicture}
\end{frame}

\begin{frame}{Solving the Problem: Concurrent Changes II}
  \begin{block}{High Level Overview}
    Store changes using a \emph{directed acyclic graph} (DAG) called
    the \emph{commit graph}.
    \begin{itemize}
      \item Nodes are saved points in time called \emph{commits}
      \item Arcs point to state from which change was made
      \item Commits with multiple children (A) are \emph{branching commits}
      \item Commits with multiple parents (M) are \emph{merge commits}
    \end{itemize}
  \end{block}
  \begin{alertblock}{Problems}
    \begin{enumerate}
      \item We care about file content not the files itself
      \item How do we merge changes?
      \item Alice and Bob are not working on the same computer
    \end{enumerate}
  \end{alertblock}
\end{frame}

\subsection{Blobs and Trees}

\begin{frame}[fragile]{Solving the Problem: Multiple Files}
  \begin{columns}
    \begin{column}{.35\linewidth}
      \begin{tikzpicture}[
          grow via three points = {%
            one child at (0.8,-0.7) and %
              two children at (0.8,-0.7) and (0.8,-1.4)
          },
          edge from parent/.style = {draw,thick},
          edge from parent path = {
            ($(\tikzparentnode\tikzparentanchor)+(.4cm,0pt)$)
              |- (\tikzchildnode\tikzchildanchor)
          },
          growth parent anchor = west,
          parent anchor = south west,
          every node/.style = {
            anchor = west,
            font = \ttfamily,
          }
        ]
        \node {Project/}
          child { node {src/}
            child { node [draw=none, fill=none] {main.c} }
            child { node [draw=none, fill=none] {Makefile} }
            child { node {\ldots} }
          }
          child [missing] {}
          child [missing] {}
          child [missing] {}
          child { node {release/}
            child { node [draw=none, fill=none] {magic} }
            child { node [draw=none, fill=none] {awesome.a} }
          };
      \end{tikzpicture}
    \end{column}
    \begin{column}{.65\linewidth}
      \begin{block}{Filesystem Jargon}
        \begin{description}[wide]
          \item[Tree] Folder / Directory
          \item[Blob] Binary Large OBject, raw data (bits) of file
            content\footnote{Demo: \texttt{hexdump} vs \texttt{stat}}
          \item[File] Blob + Metadata (Name, Date, \ldots)
        \end{description}
      \end{block}
      \begin{alertblock}{Solution}
        Treat all blobs as single entity with metadata. Examples:
        \begin{itemize}
          \item Rename file $\Rightarrow$ Same blob, commit name change
          \item Move file $\Rightarrow$ Same blob, commit change tree
        \end{itemize}
      \end{alertblock}
    \end{column}
  \end{columns}
\end{frame}

\subsection{Branches}

\begin{frame}[fragile]{Mathematical Digression: DAG}
  \begin{columns}
    \begin{column}{.55\linewidth}
      \begin{block}{Directed Acyclic Graph}
        A DAG $G = (V,A)$ is defined by a finite set of vertices $V$ and a
        finite set of \emph{arcs} $A$ and may not contain loops.
      \end{block}

      \begin{block}{Partial Order}
        DAG have a partial order relation $u \succ v$ for comparable $u,v \in V$.
      \end{block}

      \begin{alertblock}{Topological Order}
        A DAG $G = (V,A)$ has a total order $\succ^*$ by having that for all
        $(u, v) \in A$ $u \succ^* v$. If $G$ has a Hamiltonian path
        $\succ^*$
        is unique.
      \end{alertblock}
    \end{column}
    \begin{column}{.45\linewidth}
      \begin{tikzpicture}
        \matrix (m) [
          row sep = 5mm, column sep = 4mm,
          matrix of nodes, nodes = {
            circle, draw, thick, fill=orange,
            inner sep = 0pt, outer sep = 1mm, minimum size = 2.5mm,
          }
        ] {
          |[label={60:A}]| {} &                     \\
          |[label={60:B}]| {} &                      & |[label={60:C}]| {} \\
                              & |[label={90:D}]| {}  & |[label={60:E}]| {} \\
          |[label={90:F}]| {} &                      & |[label={60:G}]| {} \\
          |[label={60:H}]| {} & |[label={120:I}]| {}  &                     \\
                              & |[label={60:J}]| {} \\
        };

        \begin{scope}[thick, ->]
          \draw (m-1-1) -- (m-2-1);
          \draw (m-2-1) -- (m-3-2);
          \draw (m-3-2) -- (m-4-1);
          \draw (m-4-1) -- (m-5-1);
          \draw (m-5-1) -- (m-6-2);

          \draw (m-2-3) -- (m-3-2);

          \draw (m-1-1) -- (m-2-3);
          \draw (m-2-3) -- (m-3-3);
          \draw (m-3-3) -- (m-4-3);
          \draw (m-4-3) -- (m-5-2);
          \draw (m-5-2) -- (m-6-2);

          \draw (m-3-2) -- (m-5-2);
        \end{scope}
        
        \matrix (s) [
          right = 7mm of m,
          row sep = 4mm,
          matrix of nodes, nodes = {
            circle, draw, thick, fill=orange,
            inner sep = 0pt, outer sep = 1mm, minimum size = 2.5mm,
          }
        ] {
          |(A) [label={0:A}]| {} \\ 
          |(C) [label={0:C}]| {} \\ 
          |(B) [label={0:B}]| {} \\ 
          |(E) [label={0:E}]| {} \\ 
          |(D) [label={0:D}]| {} \\ 
          |(G) [label={0:G}]| {} \\ 
          |(F) [label={0:F}]| {} \\ 
          |(I) [label={0:I}]| {} \\ 
          |(H) [label={0:H}]| {} \\ 
          |(J) [label={0:J}]| {} \\
        };
        
        \begin{scope}[thick, ->]
          \draw (A) to[bend left] (B);
          \draw (A) to (C);
          \draw (B) to[bend left] (D);
          \draw (C) to[bend right] (D);
          \draw (C) to[bend right] (E);
          \draw (D) to[bend left] (F);
          \draw (D) to[bend right] (I);
          \draw (E) to[bend right] (G);
          \draw (F) to[bend left] (H);
          \draw (G) to[bend right] (I);
          \draw (H) to (J);
          \draw (I) to[bend right] (J);
        \end{scope}

      \end{tikzpicture}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]{Solving the Problem: Concurrent Changes III}
  \begin{columns}[t]
    \begin{column}{\linewidth}
      \centering
      \begin{tikzpicture}
        \matrix (m) [
          column sep = 8mm, row sep = 8mm,
          matrix of nodes, nodes = {
            circle, draw, thick, fill=orange,
            inner sep = 0pt, outer sep = 1mm, minimum size = 2.5mm,
          },
        ] {
          & |[fill=magenta]| {}
          & |[fill=magenta]| {}
          & |[fill=magenta]| {}
          &
          &
          & |[fill=hsr-blue]| {}
          & |[fill=hsr-blue]| {}
          &
          \\
          |[fill=lightgray]| {} 
          &    
          & {} 
          &    
          & {} 
          & {} 
          & {} 
          &
          & {}
          & {}
          \\
          &    
          &    
          & |[fill=teal]| {} 
          & |[fill=teal]| {} 
          & |[fill=teal]| {} 
          &    
          & |[fill=teal]| {} 
          & |[fill=teal]| {}
          \\
        };

        \begin{scope}[thick, <-]
          \draw (m-2-1) -- (m-1-2);

          % above first
          \draw (m-1-2) -- (m-1-3);
          \draw (m-1-3) -- (m-1-4);
          \draw (m-1-4) -- (m-2-5);

          % middle
          \draw (m-2-1) -- (m-2-3);
          \draw (m-2-3) -- (m-2-5);
          \draw (m-2-5) -- (m-2-6);
          \draw (m-2-6) -- (m-2-7);
          \draw (m-2-7) -- (m-2-9);
          \draw (m-2-9) -- (m-2-10);

          % below
          \draw (m-2-3) -- (m-3-4);
          \draw (m-3-4) -- (m-3-5);
          \draw (m-3-5) -- (m-3-6);
          \draw (m-3-6) -- (m-3-8);
          \draw (m-2-7) -- (m-3-8); % merge
          \draw (m-3-8) -- (m-3-9);

          % above second
          \draw (m-2-6) -- (m-1-7);
          \draw (m-1-7) -- (m-1-8);
        \end{scope}

        \node[right = 2mm, font=\ttfamily] at (m-1-8) {quickfix};
        \node[above = 2mm, font=\ttfamily] at (m-2-10) {master};
        \node[above = 2mm, font=\ttfamily] at (m-3-9) {feature};
      \end{tikzpicture}
    \end{column}
  \end{columns}

  \begin{columns}[t]
    \begin{column}{.5\linewidth}
      \begin{block}{Branch (informal)}
        Branches are subgraphs (subtrees) from a common anchestor in the commit
        graph.
      \end{block}
      \begin{alertblock}{Naming Branches}
        Branch names are labels on their most recent commit.
      \end{alertblock}
    \end{column}
    \begin{column}{.5\linewidth}
      \begin{exampleblock}{Examples}
        \begin{itemize}
          \item \texttt{quickfix} branch is from \texttt{master}
          \item Magenta (no name) branch was merged into \texttt{master}
          \item \texttt{master} branch was merged into \texttt{feature}
        \end{itemize}
      \end{exampleblock}
    \end{column}
  \end{columns}
\end{frame}

\subsection{Merging Strategies}

\begin{frame}[fragile]{Solving the Problem: Fast-Forward-Merge}
  \begin{columns}
    \begin{column}{.5\linewidth}
      \begin{tikzpicture}
        \matrix (m) [
          column sep = 8mm, row sep = 6mm,
          fill = lightgray!20, inner sep = 5mm, outer sep = 2mm,
          matrix of nodes, nodes = {
            circle, draw, thick, fill=orange,
            inner sep = 0pt, outer sep = 1mm, minimum size = 2.5mm,
          },
          row 1/.style = {
            nodes = {
              fill = magenta,
            }
          }
        ] {
             &    & {} & {} & {} \\
          {} & {} & \\
        };

        \begin{scope}[thick, <-]
          \draw (m-2-1) -- (m-2-2);
          \draw (m-2-2) -- (m-1-3);
          \draw (m-1-3) -- (m-1-4);
          \draw (m-1-4) -- (m-1-5);
        \end{scope}

        \begin{scope}[font=\ttfamily]
          \node[below = 1mm] at (m-2-2) {BX};
          \node[above = 1mm] at (m-1-5) {BY};
        \end{scope}

        \matrix (n) [
          below = 2cm of m,
          column sep = 8mm, row sep = 6mm,
          fill = lightgray!20, inner sep = 5mm, outer sep = 2mm,
          matrix of nodes, nodes = {
            circle, draw, thick, fill=magenta,
            inner sep = 0pt, outer sep = 1mm, minimum size = 2.5mm,
          },
        ] {
          |[fill=orange]| {} & |[fill=orange]| {} & {} & {} & {} \\
        };

        \begin{scope}[thick, <-]
          \draw (n-1-1) -- (n-1-2);
          \draw (n-1-2) -- (n-1-3);
          \draw (n-1-3) -- (n-1-4);
          \draw (n-1-4) -- (n-1-5);
        \end{scope}

        \begin{scope}[font=\ttfamily]
          \node[below = 1mm] at (n-1-5) {BX};
          \node[above = 1mm] at (n-1-5) {BY};
        \end{scope}

        \draw[very thick, ->] (m) -- node[midway, right] {in \texttt{BX} merge \texttt{BY}} (n);
      \end{tikzpicture}
    \end{column}
    \begin{column}{.5\linewidth}
      \begin{exampleblock}{History}
        \begin{enumerate}
          \item From an existing branch \texttt{BX} (with orange commits) a
            branch \texttt{BY} added new commits (magenta)
          \item We merge \texttt{BY} into \texttt{BX}
        \end{enumerate}
      \end{exampleblock}
      \begin{alertblock}{FF-Merge}
        Apply changes of commits in \texttt{BY} starting at \texttt{BX} until
        you get to \texttt{BY}. Or \texttt{BX} just needs to ``catch up'' to
        \texttt{BY}. No new commits are created.
      \end{alertblock}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]{Solving the Problem: 3-Way-Merge I}
  \begin{columns}
    \begin{column}{.5\linewidth}
      \begin{tikzpicture}
        \matrix (m) [
          column sep = 8mm, row sep = 6mm,
          fill = lightgray!20, inner sep = 5mm, outer sep = 2mm,
          matrix of nodes, nodes = {
            circle, draw, thick, fill=orange,
            inner sep = 0pt, outer sep = 1mm, minimum size = 2.5mm,
          },
          row 1/.style = {
            nodes = {
              fill = magenta,
            }
          }
        ] {
             &    & {} & {} \\
          {} & {} & |[fill=teal]| {} \\
        };

        \begin{scope}[thick, <-]
          \draw (m-2-1) -- (m-2-2);
          \draw (m-2-2) -- (m-1-3);
          \draw (m-1-3) -- (m-1-4);

          \draw (m-2-2) -- (m-2-3);
        \end{scope}

        \begin{scope}[font=\ttfamily]
          \node[below = 1mm] at (m-2-3) {BX};
          \node[above = 1mm] at (m-1-4) {BY};
        \end{scope}

        \matrix (n) [
          below = 2cm of m,
          column sep = 8mm, row sep = 6mm,
          fill = lightgray!20, inner sep = 5mm, outer sep = 2mm,
          matrix of nodes, nodes = {
            circle, draw, thick, fill=orange,
            inner sep = 0pt, outer sep = 1mm, minimum size = 2.5mm,
          },
        ] {
             &    & |[fill=magenta]| {} & |[fill=magenta]| {} \\
          {} & {} & |[fill=teal]| {} & & |[fill=hsr-blue]| {} \\
        };

        \begin{scope}[thick, <-]
          \draw (n-2-1) -- (n-2-2);
          \draw (n-2-2) -- (n-1-3);
          \draw (n-1-3) -- (n-1-4);
          \draw (n-1-4) -- (n-2-5);

          \draw (n-2-2) -- (n-2-3);
          \draw (n-2-3) -- (n-2-5);
        \end{scope}

        \begin{scope}[font=\ttfamily]
          \node[below = 1mm] at (n-2-5) {BX};
          \node[above = 1mm] at (n-1-4) {BY};
        \end{scope}

        \draw[very thick, ->] (m) -- node[midway, right] {in \texttt{BX} merge \texttt{BY}} (n);
      \end{tikzpicture}
    \end{column}
    \begin{column}{.5\linewidth}
      \begin{exampleblock}{History}
        \begin{enumerate}
          \item Branches \texttt{BX} and \texttt{BY} have new commits (magenta
            and green resp.) and share a common history (orange)
          \item We merge \texttt{BY} into \texttt{BX}
        \end{enumerate}
      \end{exampleblock}
      \begin{alertblock}{Observations}
        When you merge you are in \texttt{BX} importing changes from \texttt{BY}
        \begin{itemize}
          \item ``our'' changes are from \texttt{BX}
          \item ``their'' changes are from \texttt{BY}
        \end{itemize}
        Need to make choices, which get saved in a new merge commit.
      \end{alertblock}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]{Solving the Problem: 3-Way-Merge II}
  \begin{columns}
    \begin{column}{.55\linewidth}
      \begin{tikzpicture}
        \node[draw, very thick, teal, fill=teal!20,
          circle, minimum size = 20mm] (oc) {};

        \node[draw, very thick, magenta, fill=magenta!20, 
          circle, minimum size = 20mm, right = 15mm of oc] (tc) {};

        \node[above right = 1cm, font=\ttfamily] at (oc) {BX};
        \node[above right = 1cm, font=\ttfamily] at (tc) {BY};

        \draw (oc) pic{file = {of ours {}}};
        \draw (tc) pic{file = {tf theirs {}}};

        \node[draw, very thick, hsr-blue, fill=hsr-blue20,
          rounded corners = 5mm, minimum width = 5cm, minimum height = 2cm]
          (mc) at ($(oc)!0.5!(tc) - (0,4)$) {};

        \node[draw, thick, black, fill = white,
          minimum width = 4cm, minimum height = 1cm,]
          (mf) at (mc) {merged};

        \node[below] at (mc.south) {Merge \texttt{BY} into \texttt{BX}};

        \begin{scope}[black, line width = 1mm]
          \draw[<-] (oc.south) -- (mc);
          \draw[<-] (tc.south) -- (mc);
          \draw[] (oc.north) -- ++ (0,1);
          \draw[] (tc.north) -- ++ (0,1);
        \end{scope}

        \foreach \k/\w [count=\i] in {0/9, 1.2/5, 2.3/6, 3.2/2} {
          \node[draw, thick, teal, fill=teal!40,
            minimum height = 1cm, minimum width = \w,
            opacity = .5, inner sep = 0pt, anchor = west,
          ] (moc-\i) at ($(mf.west) + (\k,0)$) {};
          
          \draw[teal, thick, ->] (of) to[out=-90, in=90] ({moc-\i}.north);
        }

        \foreach \k/\w [count=\i] in {.6/2, 1.4/9, 3/4} {
          \node[draw, thick, magenta, fill=magenta!40,
            minimum height = 1cm, minimum width = \w,
            opacity = .5, inner sep = 0pt, anchor = west,
          ] (mtc-\i) at ($(mf.west) + (\k,0)$) {};

          \draw[magenta, thick, ->] (tf) to[out=-90, in=90] ({mtc-\i}.north);
        }
      \end{tikzpicture}
    \end{column}
    \begin{column}{.45\linewidth}
      \begin{alertblock}{3-Way-Merge}
        \begin{itemize}
          \item Use a (3-way-merge) algorithm to merge trees and blobs from
            each commit

          \item If not possible the user has to choose between `our' changes
            and `their' changes
        \end{itemize}
      \end{alertblock}
      \begin{block}{Merge Conflict}
        When the algorithm cannot merge the file automatically it is called
        \emph{merge conflict}.
      \end{block}
    \end{column}
  \end{columns}
\end{frame}

\subsection{Remotes}

\begin{frame}[fragile]{Solving the Problem: Multiple Computers I}
  \begin{columns}
    \begin{column}{.6\linewidth}
      \centering
      \begin{tikzpicture}

        \matrix (b) [
          row sep = 6mm, column sep = 6mm, 
          outer sep = 3mm, inner sep = 6mm,
          matrix of nodes, nodes = {
            draw, thick, circle, fill = teal,
            inner sep = 0pt, outer sep = .5mm, minimum size = 2mm,
          },
          draw = hsr-blue, thick, fill=hsr-blue20,
        ] {
          {} & {} &    & {} & |[fill=hsr-blue]| {} & |[fill=hsr-blue]| {} \\
             & {} & {} \\
        };
        \node[
          above, anchor = south, rotate = 90,
          font = \bfseries, text = hsr-blue,
        ] at (b.west) {Bob's PC};

        \begin{scope}[thick, <-]
          \draw (b-1-1) -- (b-1-2);
          \draw (b-1-2) -- (b-1-4);

          \draw (b-1-1) -- (b-2-2);
          \draw (b-2-2) -- (b-2-3);

          \draw[densely dashed] (b-1-4) -- (b-1-5);
          \draw[densely dashed] (b-1-5) -- (b-1-6);
        \end{scope}

        \node[above = 2mm, font = \ttfamily] at (b-1-6) {trunk};
        \node[right = 2mm, font = \ttfamily] at (b-2-3) {feat};

        \matrix (a) [
          below = 16mm of b,
          row sep = 6mm, column sep = 6mm,
          outer sep = 3mm, inner sep = 6mm,
          matrix of nodes, nodes = {
            draw, thick, circle, fill = teal,
            inner sep = 0pt, outer sep = .5mm, minimum size = 2mm,
          },
          draw = hsr-mauve, thick, fill=hsr-mauve20,
        ] {
          {} & {} &    & {} \\
             & {} & {} &    & |[fill=hsr-mauve]| {} & |[fill=hsr-mauve]| {} \\
        };
        \node[
          above, anchor = south, rotate = 90,
          font = \bfseries, text = hsr-mauve,
        ] at (a.west) {Alice's PC};

        \begin{scope}[thick, <-]
          \draw (a-1-1) -- (a-1-2);
          \draw (a-1-2) -- (a-1-4);

          \draw (a-1-1) -- (a-2-2);
          \draw (a-2-2) -- (a-2-3);

          \draw[densely dashed] (a-1-4) -- (a-2-5);
          \draw[densely dashed] (a-2-3) -- (a-2-5);
          \draw[densely dashed] (a-2-5) -- (a-2-6);
        \end{scope}

        \node[above = 2mm, font = \ttfamily] at (a-1-4) {trunk};
        \node[above = 2mm, font = \ttfamily] at (a-2-6) {feat};

        \draw [very thick, hsr-mauve, ->] (b) -- node[midway, right] {clone} (a);
      \end{tikzpicture}
    \end{column}
    \begin{column}{.4\linewidth}
      \begin{block}{Remotes and Clone}
        \footnotesize
        Other computers are called \emph{remotes}. Clone means you copy the
        commit graph on the remote machine onto yours.
      \end{block}
      \begin{exampleblock}{Example}
        \footnotesize
        \begin{enumerate}
          \item Alice has cloned Bob's (green) commit graph 
          \item Alice has merged \texttt{trunk} onto \texttt{feat} and made changes
          \item Bob has also made changes on \texttt{trunk}
        \end{enumerate}
      \end{exampleblock}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]{Solving the Problem: Multiple Computers II}
  \begin{columns}
    \begin{column}{.6\linewidth}
      \centering
      \begin{tikzpicture}

        \matrix (b) [
          row sep = 6mm, column sep = 6mm, 
          outer sep = 1mm, inner sep = 6mm,
          minimum width = 6cm,
          matrix of nodes, nodes = {
            draw, thick, circle, fill = teal,
            inner sep = 0pt, outer sep = .5mm, minimum size = 2mm,
          },
          draw = hsr-blue, thick, fill=hsr-blue20,
        ] {
          {} & {} &    & {} & |[fill=hsr-blue]| {} & |[fill=hsr-blue]| {} \\
             & {} & {} \\
        };

        \node[
          above, anchor = south, rotate = 90,
          font = \bfseries, text = hsr-blue,
        ] at (b.west) {Bob's PC};

        \node[
          anchor = south west,
          font = \ttfamily, text = hsr-blue,
        ] at (b.north west) {bob};

        \begin{scope}[thick, <-]
          \draw (b-1-1) -- (b-1-2);
          \draw (b-1-2) -- (b-1-4);

          \draw (b-1-1) -- (b-2-2);
          \draw (b-2-2) -- (b-2-3);

          \draw (b-1-4) -- (b-1-5);
          \draw (b-1-5) -- (b-1-6);
        \end{scope}

        \node[above = 2mm, font = \footnotesize\ttfamily] (bt) at (b-1-6) {trunk};
        \node[right = 2mm, font = \footnotesize\ttfamily] (bf) at (b-2-3) {feat};

        \matrix (a) [
          below = 16mm of b,
          row sep = 6mm, column sep = 6mm,
          outer sep = 1mm, inner sep = 6mm,
          minimum width = 6cm,
          matrix of nodes, nodes = {
            draw, thick, circle, fill = teal,
            inner sep = 0pt, outer sep = .5mm, minimum size = 2mm,
          },
          draw = hsr-mauve, thick, fill=hsr-mauve20,
        ] {
          {} & {} &    & {} & |[fill=hsr-blue]| {}  & |[fill=hsr-blue]| {}  \\
             & {} & {} &    & |[fill=hsr-mauve]| {} & |[fill=hsr-mauve]| {} \\
        };

        \node[
          above, anchor = south, rotate = 90,
          font = \bfseries, text = hsr-mauve,
        ] at (a.west) {Alice's PC};

        \node[
          anchor = south west,
          font = \ttfamily, text = hsr-mauve,
        ] at (a.north west) {alice};

        \begin{scope}[thick, <-]
          \draw (a-1-1) -- (a-1-2);
          \draw (a-1-2) -- (a-1-4);

          \draw (a-1-1) -- (a-2-2);
          \draw (a-2-2) -- (a-2-3);

          \draw (a-1-4) -- (a-2-5);
          \draw (a-2-3) -- (a-2-5);
          \draw (a-2-5) -- (a-2-6);

          \draw (a-1-4) -- (a-1-5);
          \draw (a-1-5) -- (a-1-6);
        \end{scope}

        \node[above = 2mm, font = \footnotesize\ttfamily] at (a-1-4) {trunk};
        \node[below = 2mm, font = \footnotesize\ttfamily] at (a-2-6) {feat};

        \node[above = 2mm, font = \footnotesize\ttfamily, hsr-blue] (rbt) at (a-1-6) {bob/trunk};
        \node[below = 2mm, font = \footnotesize\ttfamily, hsr-blue] (rbf) at (a-2-3) {bob/feat};

        \begin{scope}[very thick, dashed, opacity=.5, gray, ->]
          \draw (bt.south east) to[bend left] (rbt.north east);
          \draw (bf) to[bend right] (rbf);
          \draw (b-1-6) to[bend right] (a-1-6);
          \draw (b-1-5) to[bend right] (a-1-5);
        \end{scope}

        \draw[very thick, ->, hsr-mauve] (b.south) -- 
          node[midway, right, fill=white] {fetch} (a.north);

      \end{tikzpicture}
    \end{column}
    \begin{column}{.4\linewidth}
      \begin{block}{Fetch}
        Copy the changes of the remote git graph into your local git graph.
      \end{block}
      \begin{exampleblock}{Running Example}
        Alice fetches Bob's changes.
      \end{exampleblock}
      \begin{alertblock}{Remote Branches}
        \footnotesize
        A branch that represents changes done in another machine. When a graph
        is cloned, the machine from which it was cloned has the default name
        \texttt{origin}.
      \end{alertblock}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]{Solving the Problem: Multiple Computers III}
  \begin{columns}
    \begin{column}{.6\linewidth}
      \centering
      \begin{tikzpicture}

        \matrix (b) [
          row sep = 6mm, column sep = 6mm, 
          outer sep = 1mm, inner sep = 6mm,
          minimum width = 6cm,
          matrix of nodes, nodes = {
            draw, thick, circle, fill = teal,
            inner sep = 0pt, outer sep = .5mm, minimum size = 2mm,
          },
          draw = hsr-blue, thick, fill=hsr-blue20,
        ] {
          {} & {} &    & {} & |[fill=hsr-blue]| {}  & |[fill=hsr-blue]| {}  \\
             & {} & {} &    & |[fill=hsr-mauve]| {} & |[fill=hsr-mauve]| {} \\
        };

        \node[
          above, anchor = south, rotate = 90,
          font = \bfseries, text = hsr-blue,
        ] at (b.west) {Bob's PC};

        \node[
          anchor = south west,
          font = \ttfamily, text = hsr-blue,
        ] at (b.north west) {bob};

        \begin{scope}[thick, <-]
          \draw (b-1-1) -- (b-1-2);
          \draw (b-1-2) -- (b-1-4);

          \draw (b-1-1) -- (b-2-2);
          \draw (b-2-2) -- (b-2-3);

          \draw (b-1-4) -- (b-2-5);
          \draw (b-2-3) -- (b-2-5);
          \draw (b-2-5) -- (b-2-6);

          \draw (b-1-4) -- (b-1-5);
          \draw (b-1-5) -- (b-1-6);
        \end{scope}

        \node[above = 2mm, font = \footnotesize\ttfamily] at (b-1-6) {trunk};
        \node[below = 2mm, font = \footnotesize\ttfamily] at (b-2-3) {feat};

        \node[above = 2mm, font = \footnotesize\ttfamily, hsr-mauve] (rat) at (b-1-4) {alice/trunk};
        \node[below = 2mm, font = \footnotesize\ttfamily, hsr-mauve] (raf) at (b-2-6) {alice/feat};

        \matrix (a) [
          below = 16mm of b,
          row sep = 6mm, column sep = 6mm,
          outer sep = 1mm, inner sep = 6mm,
          minimum width = 6cm,
          matrix of nodes, nodes = {
            draw, thick, circle, fill = teal,
            inner sep = 0pt, outer sep = .5mm, minimum size = 2mm,
          },
          draw = hsr-mauve, thick, fill=hsr-mauve20,
        ] {
          {} & {} &    & {} & |[fill=hsr-blue]| {}  & |[fill=hsr-blue]| {}  \\
             & {} & {} &    & |[fill=hsr-mauve]| {} & |[fill=hsr-mauve]| {} \\
        };

        \node[
          above, anchor = south, rotate = 90,
          font = \bfseries, text = hsr-mauve,
        ] at (a.west) {Alice's PC};

        \node[
          anchor = south west,
          font = \ttfamily, text = hsr-mauve,
        ] at (a.north west) {alice};

        \begin{scope}[thick, <-]
          \draw (a-1-1) -- (a-1-2);
          \draw (a-1-2) -- (a-1-4);

          \draw (a-1-1) -- (a-2-2);
          \draw (a-2-2) -- (a-2-3);

          \draw (a-1-4) -- (a-2-5);
          \draw (a-2-3) -- (a-2-5);
          \draw (a-2-5) -- (a-2-6);

          \draw (a-1-4) -- (a-1-5);
          \draw (a-1-5) -- (a-1-6);
        \end{scope}

        \node[above = 2mm, font = \footnotesize\ttfamily] (at) at (a-1-4) {trunk};
        \node[below = 2mm, font = \footnotesize\ttfamily] (af) at (a-2-6) {feat};

        \node[above = 2mm, font = \footnotesize\ttfamily, hsr-blue] at (a-1-6) {bob/trunk};
        \node[below = 2mm, font = \footnotesize\ttfamily, hsr-blue] at (a-2-3) {bob/feat};

        \begin{scope}[very thick, dashed, opacity=.5, gray, ->]
          \draw (at.north west) to[bend left] (rat.south west);
          \draw (af.north east) to[bend right] (raf.south east);

          \draw (a-2-5) to[bend right] (b-2-5);
          \draw (a-2-6) to[bend right] (b-2-6);
        \end{scope}

        \draw[very thick, <-, hsr-mauve] ($(b.south) + (.1,0)$)
          -- node[midway, right, fill=white] {push} ($(a.north) + (.1,0)$);

        \draw[very thick, <-, hsr-blue] ($(b.south) - (.1,0)$)
          -- node[midway, left, fill=white] {fetch} ($(a.north) - (.1,0)$);

      \end{tikzpicture}
    \end{column}
    \begin{column}{.4\linewidth}
      \begin{block}{Push}
        Copy the changes of your local git graph to the remote machine.
      \end{block}

      \begin{exampleblock}{Running Example}
        This is the same as if Bob had fetched Alice's changes.
      \end{exampleblock}

      \begin{alertblock}{Network Access}
        \footnotesize
        In practice you cannot directly access other people's machines, so
        people use a third computer to which both parties have access (more
        later).
      \end{alertblock}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]{Solving the Problem: Multiple Computers IV}
  \begin{columns}
    \begin{column}{.6\linewidth}
      pull = fetch + merge
    \end{column}
  \end{columns}
\end{frame}

\section{The Implementation}

\subsection{Hash and Merkle DAG}

\begin{frame}{Mathematical Digression: Hashes and Merkle DAG}
  \begin{columns}
    \begin{column}{.5\linewidth}
      \textbf{``One-way fast'' functions}
      \begin{block}{Hash Function}
        A (cryptographic) \emph{hash} function is an $h : \Omega \to \{0,1\}^d$
        for a fixed hash length $d$ such that:
        \begin{enumerate}
          \item Given $y = h(x)$ it is hard to find $x$
          \item It is hard to find $x,y \in \Omega$ s.t. $h(x) = h(y)$
	  \item Given $h(x)$ it is hard to find $y$ s.t. $h(x) = h(y)$
          \item Given $h(x)$ and a function $f$ it is hard to find $h(f(x))$
        \end{enumerate}
      \end{block}
      Hashes are \emph{not} unique!
    \end{column}
    \begin{column}{.5\linewidth}
      \begin{block}{Merkle DAG}
        A Merkle DAG is a DAG $G = (V,A)$ with a hash
        \[
          h : V \times \{0,1\}^d \to \{0,1\}^d
        \]
        that defines a label function
        \begin{align*}
          \ell(v) &= h\left(v, \sum_{u \in \operatorname{n}^+(v)} \ell(u) \right)
        \end{align*}
      \end{block}
      \begin{alertblock}{Properties}
        \begin{itemize}
          \item Immutable data structure
          \item Cryptographic verification
        \end{itemize}
      \end{alertblock}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]{Mathematical Digression: Visualizing Merkle DAGs}
  \begin{columns}
    \begin{column}{\linewidth}
      To compute the label of a node, you need to first compute the label of
      all nodes on which it depends. Changing a label has a cascading effect on
      descendents.
      \vspace{5mm}
      \begin{tikzpicture}
        \matrix (m) [
          row sep = 2mm, column sep = 10mm,
          matrix of nodes, nodes = {
            circle, draw, thick, fill=orange,
            inner sep = 0pt, outer sep = 1mm, minimum size = 2.5mm,
          }
        ] {
          & |[label={120:B}] (B)| {}
          &
          &
          & |[label={ 90:H}] (H)| {}
          \\
            |[label={100:A}] (A)| {}
          &
          &
          & |[label={ 90:E}] (E)| {}
          \\
          & |[label={ 90:C}] (C)| {}
          & |[label={ 90:D}] (D)| {}
          &
          & |[label={ 90:G}] (G)| {}
          \\
          &
          &
          & |[label={ 90:F}] (F)| {}
          \\
        };

        \begin{scope}[thick, <-]
          \draw (A) to[bend left] (B);
          \draw (B) to[out = 0, in = 120] (E);
          \draw (E) to[bend left] (H);

          \draw (A) -- (E);
          
          \draw (A) to[bend right] (C);
          \draw (C) -- (D);
          \draw (D) to[bend right] (E);
          \draw (E) to[bend right] (G);

          \draw (D) to[bend right] (F);
          \draw (F) to[bend right] (G);
        \end{scope}

        \node[below left = 1mm, rotate=30]  at (A) {$h(\mathsf{A}, 0)$};
        \node[above right = 2mm, rotate=30] at (B) {$h(\mathsf{B}, \ell(\mathsf{A}))$};
        \node[right = 2mm] at (E) {$h(\mathsf{E}, 
          \ell(\mathsf{A}) \oplus \ell(\mathsf{B}) \oplus \ell(\mathsf{D})))$};

        \node[below left = 2mm, rotate=30, anchor = east] at (C) {$h(\mathsf{C}, \ell(\mathsf{A}))$};
        \node[below left = 2mm, rotate=30, anchor = east] at (D) {$h(\mathsf{D}, \ell(\mathsf{C}))$};
        \node[below = 2mm] at (F) {$h(\mathsf{F}, \ell(\mathsf{D}))$};
        \node[right = 2mm] at (H) {$h(\mathsf{H}, \ell(\mathsf{E}))$};
        \node[right = 2mm] at (G) {$h(\mathsf{G}, \ell(\mathsf{E}) \oplus \ell(\mathsf{F}))$};
      \end{tikzpicture}
    \end{column}
  \end{columns}
\end{frame}

\subsection{Git Commits}

\begin{frame}[fragile]{Git Commits}
  \begin{block}{Commit Contents}
    \begin{itemize}
      \item Content (Blobs and Trees) hash 
      \item Parent(s) commit(s) hash(es)
      \item Metadata: Author, Date, Message
    \end{itemize}
  \end{block}
  \begin{exampleblock}{Example}
  \centering\scriptsize
\begin{verbatim}
commit 1cfdf5c198f1c74c2f894067baf4670f5bca8e70
Author: Nao Pross <np@0hm.ch>
Date:   Wed Feb 9 19:53:06 2022 +0100

  Fix arrayobject.h path on Debian based distros
  
  On Debian Linux and its derivatives such as Ubuntu and LinuxMint, Python
  packages installed through the package manager are kept in a different
  non-standard directory called 'dist-packages' instead of the normal
  'site-packages' [1].
  
  To detect the Linux distribution the 'platform' library (part of the
  Python stdlib) provides a function 'platform.freedesktop_os_release()'
  that parses a standard file '/etc/os-release' available in most Linux
  distributions [2]. However this function is rather new (Python >= 3.10)
  and unavailable in most python installations, so the core of its
  functionaly was reimplemented here.
  
  [1]: https://wiki.debian.org/Python#Deviations_from_upstream
  [2]: https://docs.python.org/3/library/platform.html#linux-platforms
  
  Signed-off-by: Jonas Schmid <schmid@stettbacher.ch>
\end{verbatim}
  \end{exampleblock}
\end{frame}

\subsection{Git Repositories}

\begin{frame}{Git Repositories}
  \begin{columns}
    \begin{column}{.6\linewidth}
      \begin{tikzpicture}[
          grow via three points = {%
            one child at (0.8,-0.7) and %
            two children at (0.8,-0.7) and (0.8,-1.4)
          },
          edge from parent/.style = {draw, thick},
          edge from parent path = {
            ($(\tikzparentnode\tikzparentanchor)+(.4cm,0pt)$)
              |- (\tikzchildnode\tikzchildanchor)
          },
          growth parent anchor=west,
          parent anchor=south west,
          every node/.style={
            anchor=west,
          },
        ]

        \begin{scope}[font=\ttfamily]
        \node [draw=gray, fill = lightgray!20] (P) at (-5, 4) {Project/}
          child { node (G) [draw=red, fill=red!10] {.git/} }
          child { node {src/}
            child { node [draw=none, fill=none] {main.c} }
            child { node [draw=none, fill=none] {Makefile} }
            child { node {\ldots} }
            }
            child [missing] {}
            child [missing] {}
            child [missing] {}
            child { node {release/}
                child { node [draw=none, fill=none] {magic} }
                child { node [draw=none, fill=none] {awesome.a} }
            };
        \end{scope}

        \visible<2->{
          \draw[black] pic{db} node (DB) {};
          \node[below=.3cm, align=center, text width = 2cm] (DB.south) {Repository (index)};

          \draw[very thick, ->]
            ($(G.east)+(.2,0)$) to[out=0, in=90] ($(DB.north)+(0,1.6)$);

          \node[right = 2cm of P, font=\bfseries] (W) {Work Tree};
          \draw[very thick, <-] ($(P.east)+(.2,0)$) -- (W);
        }
      \end{tikzpicture}
    \end{column}
    \begin{column}{.4\linewidth}
      \begin{block}{Work Tree}
        Root of your project, contains (hidden) \texttt{.git}.
        \textbf{Never delete \texttt{.git}}.
      \end{block}

      \begin{block}{Repository}
        \begin{itemize}
          \item Commit graph (Blobs, \ldots)
          \item Staging Area (will come next)
        \end{itemize}
      \end{block}
    \end{column}
  \end{columns}
\end{frame}

\section{Using Git}

\subsection{The Conceptual Areas}

\begin{frame}[fragile]{The 3 (or 4) Conceptual Areas of Git}
  \begin{columns}
    \begin{column}{.95\paperwidth}
      \centering
      \begin{tikzpicture}[]
        % \draw[gray,step=0.25] (-2, -5) grid (10, 2.5);
        % \clip (-2, -5) rectangle (10, 2.5);
        \node (tracked) at (0,0) [on background layer, 
          draw, thick, hsr-mauve, fill=hsr-mauve20,
          minimum width = 3cm, minimum height = 3cm,
        ] {};

        \node (fs) at ($(tracked.north) + (0, .25)$) [
          on background layer,
          anchor = north,
          draw, thick, gray, dashed,
          minimum width = 3.5cm, minimum height = 6.5cm,
        ] {};

        \node (staged) [on background layer, 
          right = 1cm of tracked.north east, anchor = north west,
          draw, thick, hsr-blue, fill=hsr-blue20,
          minimum width = 3cm, minimum height = 6cm,
        ] {};

        \node (graph) [on background layer, 
          right = 1cm of staged.north east, anchor = north west,
          draw, thick, hsr-lakegreen, fill=hsr-lakegreen20,
          minimum width = 3cm, minimum height = 6cm,
        ] {};

        \node (storage) at ($(staged.north west) + (-.25, .25)$) [
          on background layer,
          anchor = north west,
          draw, thick, gray, dashed,
          minimum width = 7.5cm, minimum height = 6.5cm,
        ] {};

        % area labels
        \node at (tracked.north west)
          [anchor = north west, font = \bfseries] {Tracked};

        \node at (staged.north west)
          [anchor = north west, font = \bfseries] {Staging Area};

        \node at (graph.north west)
          [anchor = north west, font = \bfseries] {Commit Graph};

        \node at (fs.north west)
          [anchor = south west, font = \bfseries, gray] {Work Tree};

        \node at (tracked.south west)
          [anchor = north west, gray] {Untracked};

        \node at (storage.north west)
          [anchor = south west, font = \bfseries, gray] {Storage \texttt{.git}};

        % commit graph
        \matrix (m) at (graph) [
          row sep = 8mm, column sep = 5mm,
          matrix of nodes,
          nodes = {
            draw, thick, circle, fill = orange,
            inner sep = 0pt, outer sep = .5mm, minimum size = 2mm,
          }
        ] {
          {} \\
          {} & {} \\
          {} & {} \\
          {} \\
          |(commit) [fill=magenta]| {} \\
        };

        \begin{scope}[thick, <-]
          \draw (m-1-1) -- (m-2-1);
          \draw (m-2-1) -- (m-3-1);
          \draw (m-3-1) -- (m-4-1);

          \draw (m-1-1) to[out=-90, in=90] (m-2-2);
          \draw (m-2-2) -- (m-3-2);
          \draw (m-3-2) to[out=-90, in=90] (m-4-1);

          \draw[dashed] (m-4-1) -- (commit);
        \end{scope}

        % files
        \draw (tracked) pic{file = {a a.c {}}};
        \draw (staged |- tracked) pic{file = {as a.c {}}};

        \draw pic{file = {u u.c {below = 1cm of tracked.south}}};
        \draw (u -| as) pic{file = {us u.c {}}};

        % arrows
        \begin{scope}[thick] 
          \draw[->] (a) to[bend left = 20] 
            node[midway, above, fill = white] {add} (as);

          \draw[<-] (a) to[bend right = 20]
            node[midway, below, fill = white] {reset} (as);

          \draw[->] (u) to[bend left = 20]
            node[midway, above, fill = white] {add} (us);

          \draw[<-] (u) to[bend right = 20]
            node[midway, below, fill = white] {reset} (us);
        \end{scope}

        % Commit
        \draw[draw = magenta, thick, fill = magenta!80, path fading = west] 
          (as.north east) -- (commit.west) -- (us.south east) -- cycle;


        \path (us.south east) -- node (M) [pos = .35] {} (as.north east);
        \path (M) -- node [pos = .85, sloped, font={\bfseries\large},
          black, anchor = east] {commit} (commit.west);

        % \draw[black] (current bounding box.north west) 
        %   rectangle (current bounding box.south east);
      \end{tikzpicture}
    \end{column}
  \end{columns}
\end{frame}

\subsection{Branches and Merging}

\begin{frame}{Branches, Remotes and your HEAD}
\end{frame}

\begin{frame}{Auomatic Merge Failed (Conflicts)}
  Most common issue (mentioned in XKCD)
\end{frame}

\subsection{Best Practices}

\begin{frame}{What is a Commit Anyways?}
\end{frame}

\begin{frame}{Trunk, Feature Branches}
\end{frame}

\begin{frame}{Releases and Tags}
\end{frame}

\subsection{GitHub and Others}

\begin{frame}{Git Services (GitHub, GitLab, \ldots)}
\end{frame}

\subsection{Forks}

\begin{frame}{Forking Projects}
\end{frame}

\begin{frame}[fragile]{Forking and Pull / Merge Requests}
  \resizebox{!}{.8\textheight}{
    \begin{tikzpicture}
      \visible<1->{
        % rick's repos
        \draw (0, 0)          pic{db} node (DBA1){} node[below=.2cm] {\texttt{proj}};
        \draw (DBA1) ++(6, 0) pic{db} node (DBA2){} node[below=.2cm] {\texttt{rick/proj}};
      }

      % morty's repos
      \visible<5->{
        \draw (DBA1) ++(0,-5) pic{db} node (DBB1){} node[below=.2cm] {\texttt{proj}};
      }
      \visible<4->{
        \draw (DBB1) ++(6, 0) pic{db} node (DBB2){} node[below=.2cm] {\texttt{morty/proj}};
      }


      \begin{pgfonlayer}{bg}
        \visible<1->{

          % laptop background
          \draw[blue!80, fill=blue!10!white]
          (DBA1.north west) ++(-1.2, 3) node[black, anchor=north west, below right=.2cm]{Laptop}
          rectangle ($(DBB1.south east) + (1.2, -1.5)$);

          % server background
          \draw[red!80, fill=red!10!white]
          (DBA2.north west) ++(-1.2, 3) node[black, anchor=north west, below right=.2cm]{Server}
          rectangle ($(DBB2.south east) + (1.2, -1.5)$);

        }

        % rick's background
        \visible<2->{
          \draw[magenta!80, fill=magenta!20, fill opacity=.8]
          (DBA1.north west) ++(-2.5, 2)
          node[black, anchor=north east, rotate=90, below left=.3cm] {Rick}
          rectangle ($(DBA2.south east) + (2, -.8)$);
        }

        % morty's background
        \visible<3->{
          \draw[cyan!80, fill=cyan!20, fill opacity=.8]
          (DBB1.north west) ++(-2.5, 2)
          node[black, anchor=north east, rotate=90, below left=.3cm] {Morty}
          rectangle ($(DBB2.south east) + (2, -.8)$);
        }
      \end{pgfonlayer}

      \visible<1->{
        % rick's arrow
        \draw[darkgray, ultra thick, <->]
        ($(DBA1.north east)+(.75,.5)$) to node[pos=.5, above]
        {\footnotesize\texttt{push / pull}} ($(DBA2.north west)+(-.75,.5)$);
      }

      \visible<5->{
        % morty's arrow
        \draw[darkgray, ultra thick, <->]
        ($(DBB1.north east)+(.75,.5)$) to node[pos=.5, above]
        {\footnotesize\texttt{push / pull}} ($(DBB2.north west)+(-.75,.5)$);
      }

      \visible<4->{
        % forking arrow
        \draw[black, ultra thick, ->]
        ($(DBA2.south west)+(0,-.75)$) to node[
          pos=.5, left=.2cm, thick, draw=red, fill=white
        ]{\textbf{\texttt{fork}}} ($(DBB2.north west)+(0,1.75)$);
      }

      % PR arrow
      \visible<6->{
        \draw[black, ultra thick, <-]
        ($(DBA2.south east)+(0,-.75)$) to node[
          pos=.5, right=.2cm, thick, draw=red, fill=white
        ]{\textbf{\texttt{pull request}}} ($(DBB2.north east)+(0,1.75)$);
      }

      % \visible<6->{
      % \draw[darkgray, ultra thick, ->]
      % ($(DBA2.south west)+(-1,-.5)$) to[bend right] node[pos=.6, below right, rotate=30]
      %{\texttt{pull}}($(DBB1.north east)+(.75,1.5)$);
      % }
    \end{tikzpicture}
  }
\end{frame}

\section{Extras (to flex)}

\begin{frame}[fragile]{Mathematical Digression: Logarithmic Search I}
  \begin{columns}
    \begin{column}{.5\linewidth}
      \centering
      \begin{tikzpicture}[
          point/.style = {
            draw, circle, fill=lightgray, minimum size=1mm,
            inner sep = 0pt, thick,
          }
        ]
        % \draw[gray, densely dotted, step=.5] grid (5, 3);
        % \draw[thick, -latex] (0,0) -- (.5,0) node[right] {$\hat{\mathbf{x}}$};
        % \draw[thick, -latex] (0,0) -- (0,.5) node[above] {$\hat{\mathbf{y}}$};

        % \node[point, label={60:$p_1$}] at (1.3,1.6) {};
        % \node[point, label={60:$p_4$}] at (2.3,0.9) {};
        % \node[point, label={60:$p_5$}] at (3.1,2.2) {};
        % \node[point, label={60:$p_3$}] at (3.9,1.1) {};
        % \node[point, label={60:$p_2$}] at (2.9,0.4) {};
        % \node[point, label={60:$p_6$}] at (0.7,2.4) {};
        % \node[point, label={60:$p_2$}] at (1.1,0.5) {};

        % \node (Q) at (2.75,1.7) [
        %   thick, draw=gray, fill = gray!50, opacity=.35,
        %   minimum width = 1.75cm, minimum height = .7cm,
        %   anchor = south west,
        % ] {$Q$};

        % \draw[thick, draw=red!80!black, fill=red, opacity=.2] 
        %   (0,0) rectangle (2.5, 3);

        % \draw[thick, draw=magenta!80!black, fill=magenta, opacity=.2]
        %   (2.5,0) rectangle (5, 1.5);

        % \draw[thick, draw=blue!80!black, fill=blue, opacity=.2]
        %   (2.5,1.5) rectangle (3.75,3);
      \end{tikzpicture}

      \vspace{5mm}

      \begin{tikzpicture}[
          every node/.style = {
            draw, circle, fill=red!40, minimum size=1.4mm,
            inner sep = 0pt, thick, font = \tiny,
          },
          edge from parent/.style = { draw, semithick },
          level distance = 5mm,
          level 1/.style = { sibling distance = 30mm, nodes = { fill = red!40, }, },
          level 2/.style = { sibling distance = 15mm, nodes = { fill = magenta!40, }, },
          level 3/.style = { sibling distance = 7.5mm, nodes = { fill = blue!40, }, },
          level 4/.style = {
            sibling distance = 5mm,
            level distance = 8mm,
            edge from parent/.append style = { densely dotted },
            nodes = { fill = none, draw = none, font = \footnotesize},
          },
        ]
        \node[fill = black, label={90:T}] {}
          child {
            node[label={100:L}] {}
            child {
              node[label={100:U}] {}
              child { node[label={100:L}] {} child { node {$p_6$} } }
              child { node[label={60:R}] {} child { node {$p_1$} } }
            }
            child {
              node[label={60:D}] {}
              child { node[label={100:L}] {} child { node {$p_2$} } }
              child { node[label={60:R}] {} child { node {$p_4$} } }
            }
          }
          child {
            node[label={60:R}] {}
            child {
              node[label={100:U}] {}
              child { node[label={100:L}] {} child { node {$p_5$} } }
              child[missing] { node[label={60:R}] {} child { node {} } }
            }
            child {
              node[label={60:D}] {}
              child { node[label={100:L}] {} child { node {$p_2$} } }
              child { node[label={60:R}] {} child { node {$p_3$} } }
            }
          }
        ;
      \end{tikzpicture}
    \end{column}
    \begin{column}{.5\linewidth}
      \begin{block}{Toy Problem}
        Given a set of disjoint intervals $S = \{J_1, \ldots, J_n\}$, $J_i
        \subset \mathbb{R}$ find to which interval belongs $q \in \bigcup_i
        J_i$.
      \end{block}
      \begin{block}{Naive Solution}
        For every $J_i \in S$ interval check if $q \in J_i$. This is $O(n)$.
      \end{block}
      \begin{alertblock}{Logarithmic Search Intuition}
        Intervals can be ordered
      \end{alertblock}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{Mathematical Digression: Logarithmic Search II}
  \begin{columns}
    \begin{column}{.6\linewidth}
      \begin{block}{Chopping the Search Space}
        Recursively partition $A \subset \mathbb{R}^2$ containing points into
        disjoint subsets
        \begin{align*}
          A &= A_\mathsf{R} \cup A_\mathsf{L}\\
          A_\mathsf{L} &= A_\mathsf{LU} \cup A_\mathsf{RU} &
          A_\mathsf{R} &= A_\mathsf{RU} \cup A_\mathsf{LU} \\
          A_\mathsf{LU} &= A_\mathsf{LUL} \cup A_\mathsf{LUR} & 
          A_\mathsf{RU} &= \ldots 
        \end{align*}
      \end{block}

      \begin{alertblock}{Observation}
        At every level $A = A_\mathsf{X}\cup A_\mathsf{Y}$
        \begin{enumerate}
          \item If $Q \cap A_\mathsf{X} = \emptyset$ then $Q \subset A_\mathsf{Y}$
          \item If $Q \cap A_\mathsf{Y} = \emptyset$ then $Q \subset A_\mathsf{X}$
          \item Otherwise $Q \subset R$
        \end{enumerate}
      \end{alertblock}
    \end{column}
    \begin{column}{.4\linewidth}
      \begin{alertblock}{Logarithmic Search}
        Start with $A$ and in each case do
        \begin{enumerate}
          \item Repeat with $A := A_\mathsf{Y}$
          \item Repeat with $A := A_\mathsf{X}$
          \item Check $p \in Q$ for all $p \in A$
        \end{enumerate}
        Does not check every $p \in P$ (fast for large $n$!).
      \end{alertblock}
      \begin{block}{Complexity (Landau)}
        Base $b$ logarithmic search is $\mathcal{O}(\log_b(n))$. In this case
        $b = 2$.
      \end{block}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{Git Bisect Theory}
  \begin{columns}
    \begin{column}{.5\linewidth}
      \begin{block}{Purpose}
        You are looking for a commit that did something, e.g.
        \begin{itemize}
          \item Introduced a bug
          \item Deleted / added something
          \item Anything really
        \end{itemize}
      \end{block}
      \begin{alertblock}{Basic Idea}
        \begin{enumerate}
          \item Take commit graph $G = (V,A)$ we want to find $\bar{v} \in V$
            that did above
          \item Topologically sort $G$
          \item Logarithmic search $\bar{v}$ in $G$
        \end{enumerate}
      \end{alertblock}
    \end{column}
    \begin{column}{.5\linewidth}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{Git Bisect Practice}
\end{frame}

\begin{frame}{Outlook}
  \begin{block}{Learn More}
    Git and its ecosystem have many more features
    \begin{itemize}
      \item Stash
      \item Rebase
      \item Blame
      \item LFS (Large File System)
      \item Email workflow (e.g. \texttt{https://sr.ht})
      \item Integration with CI (e.g. GitHub Actions, GitLab Workers)
    \end{itemize}
  \end{block}
\end{frame}

\end{document}
